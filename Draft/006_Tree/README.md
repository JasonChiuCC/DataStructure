# 定義
```
樹用來處理 1 對多的情況,定義如下
樹是 n (n>= 0) 個節點的有限集合(所以 Tree 是可以沒有節點的 = 空樹)
1. 存在唯一的根 Root
2. 當 n > 1 時,其餘節點可分為 m (m>0)個互不相交的有限集合 T1,T2,.....Tm,其中每個集合也算一棵樹
並稱為根的子樹,注意子樹是"互不相交"的
```

# 節點

```
節點本身有一個資料元素,及多個指向子樹的分支
一個"節點"擁有的"子樹數量"稱為節點的"度"(Degree)

如果某個節點的度  = 0 ,表示她沒沒有子樹,所以它是葉子節點(Leaf)/終端節點(Termaimal Node)
如果某個節點的度 != 0 ,稱為分支節點(Branch)/非終端節點(Non-Termainal Node),這些分支節點也稱內部節點(Internal Node)

一棵樹的度 = 樹中某節點最大的度
例如:

A(2)
| \
|  \
|   \
B(1) C(2)---- E(1) --- J(0)
|        |
D(3)     +--- F(0)
|
+--------- G(0)
     |
     +---- H(0)
     |
     +---- I(0)

此棵樹最大度數 = 3
```

# 親戚關係
```
很明顯 A 的孩子有 B 和 C
B 的雙親(Parent) = A

擁有相同雙親的節點為兄弟(Slibling) 例如 B 和 C 為兄弟
某節點的祖先 = 從某節點到樹的根結點都為祖先
例如 H 到 Root 會經過 D->B->A 所以 D/B/A 都為 H 的祖先

反之某節點的子孫 = 某節點的所有子樹節點
例如 D 的子孫 = G/H/I
```

# 其他
```
樹的階層(由 Root 開始算)
A       = Lv1
B/C     = Lv2
D/E/F   = Lv3
G/H/I/J = Lv4
.........

另外如果節點的雙親在同一 Lv 則稱為堂兄弟
例如:
J 的雙親 = E
I 的雙親 = D
且 E/D 都在 Lv3
所以 J/I 為堂兄弟

樹最大的高度/深度 = 最大階層 = 4
```

# 樹的儲存結構
```
一般簡單的儲存結構分為
1.順序儲存:類似陣列,把一塊連續的空間分配給我們使用
2.鏈結儲存:類似 LinkList,空間不一定連續,單位彼此之間會儲存下一個單元的位址

而樹的儲存結構可類用上述兩種結構所儲存起來
```

# 雙親標記法
```
雙親: 每個節點一定有雙親(除了 Root ),所以我們可以用指標儲存雙親的位置
Node {
    data    // Node 本身資料
    parent  // Node 雙親資料
}

在物理空間上面,我們是以順序儲存結構來儲存節點 => 也就是利用陣列來儲存節點

Tree = [N1,N2,N3,N4.......Nm]

所以 Node 中的 Praent 其實是儲存 Tree 陣列中的某個元素的位置
以下用程式碼表示"樹"和"節點":

let MAX_TREE_SIZE   = 100
typealias TElemType = Int

// 節點
struct PTNode {
    var data    : TElemType = 0  // 節點資料
    var parent  : Int       = 0  // 雙親位置
}

// 樹
struct PTree {
    var nodes       = [PTNode](count: MAX_TREE_SIZE, repeatedValue: PTNode()) // 節點陣列
    var rootPos     : Int    = 0     // Root 位置
    var nodeCount   : Int    = 0     // Node 數量
}

Root 的雙親可以設為 -1              
             A(0)
           /   \
          B(1)  C(2)
         /     / \
        D(3)  E(4)F(5)
      / |  \    \
    G(6)H(7)I(8) J(9)
     
節點陣列可這樣儲存:
parent : -1  0  0  1  2  2  3  3  3  4   -> 雙親的陣列位置
         [A, B, C, D, E, F, G, H, I, J]
idx :     0  1  2  3  4  5  6  7  8  9
     
     
但是這樣沒法找孩子
所以可以多個欄位儲存"左孩子節點" 例如 C 左孩子為 E
..... 有很多方法可以做,但重點是你需要做什麼或找什麼
並不是把所有資訊都記錄下來就好,而是看你需要什麼
```

# 孩子標記法
```
另一種思考模式,就是 Node 中紀錄所有孩子的位置
但樹中每個 Node 孩子數量不同,所以以樹的度(最多孩子的個數)來做為陣列大小
類如上述的樹的度 = 3 (因為 D 有 3 個孩子,是樹中最多的孩子)
所以每個 Node 紀錄孩子指標的大小 = 3 

缺點:當 Node 度相差很多時(類如有些是 1 有些是 20),那很明顯 Node 為 1 的就浪費 19 個空間
優點:當 Node 度相差很少時,這時使用這種方法就是優點
```

# 雙親孩子標記法
```
先把每個節點放入"順序結構"中,然後每個節點的孩子用"鏈結儲存"結構來儲存
0 A -> 1 -> 2
1 B -> 3
2 C -> 4 -> 5
3 D -> 6 -> 7 -> 8 
4 E -> 9
5 F
6 G
7 H
8 I
9 J

由此可以,假設有 N 個節點有孩子,那就會有 N 個鏈結串列
不過我們不知道某個節點的雙親,所以改良一下如下
    parent
0 A [-1]   -> 1 -> 2
1 B [ 0]   -> 3
2 C [ 0]   -> 4 -> 5
3 D [ 1]   -> 6 -> 7 -> 8 
4 E [ 2]   -> 9
5 F [ 2]
6 G [ 3]
7 H [ 3]
8 I [ 3]
9 J [ 4]
```

# 孩子兄弟標記法
```
還有另一種方法是一個節點中紀錄"第一個孩子"和"右兄弟"
舉例來說 B 的第一個孩子是 D ,右兄弟是 C (因為雙親都是 A )
所以圖示如下:

往下是孩子,往右是兄弟:
A - x
|
B - C - x
|   |
D   E - F
|   |
G   J
|   
H
|
I

優點:找某節點的"孩子"很方便,例如找 A 的孩子 -> B 如果 B 有兄弟代表也是 A 的孩子 -> C
缺點:無法找雙親
```

# 二元樹
```
適用場合:對錯,01,上下,正反,真假,開關
定義: N (N>= 0) 個節點的有限集合,由 Root 和(兩顆)互不相交的左子樹和右子樹所組成
所以要是有某個節點有 3 個以上的小孩就不能稱二元樹

◎ 度不能大於 2
◎ 左/右子樹有順序,次序不能顛倒
◎ 即使節點只有一個孩子,也要區分是左子樹還是右子樹

注意,因為左右樹是不一樣的所以以下是不同的樹
  O          O      O      O         O
 / \        /      /        \         \
O   O      O      O          O         O
          /        \        /           \
         O          O      O             O
```


# 特殊二元樹
```
斜樹:
  所有節點只有左子樹:左斜樹
  所有節點只有右子樹:右斜樹
```

# 完滿二元樹
```

```