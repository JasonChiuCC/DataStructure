# 演算法特性
```
(1) 輸入:   具有 0 個或多個輸入
(2) 輸出:   具有 1 個或多個輸入(因為演算法一定要有輸出)
(3) 有限性: 自動結束不會出現無窮迴圈
(4) 確定性: 演算法每一個步驟都要有確定的含意
(5) 可行性: 必須要電腦可以執行,也就是演算法要可以轉為程式
```

# 事前分析估計法
```
舉例:
(1)
int i,sum=0,n=100      // 執行 1   次
for(i=1;i<=n;i++){     // 執行 n+1 次
    sum = sum+1        // 執行 1   次
}
printf("sum")          // 執行 1   次
總共執行 = 1+(n+1)+1+1 = 4+n 次

(2)
int i,sum=0,n=100      // 執行 1   次
sum = (1+n)*n/2        // 執行 1   次
printf("sum")          // 執行 1   次
總共執行 = 1+1+1 = 3 次


第一種演算法會根據 n 來決定執行次數
演算法邏輯可以表示 f() 傳入參數為 n
所以將 n 傳入演算法 = f(n) = 執行次數 = n 次

如果是雙迴圈的話執行次數會變為 n*n
表示為 f(n) = n*n
```

# 函式的快慢
```
假設有 A,B 演算法
A = 2n+3 (2n 表示有2個迴圈, 3 表示有3次"回傳"或"計算")
B = 3n+1 (3n 表示有3個迴圈, 1 表示有3次"回傳"或"計算")

哪一個比較快?
整理來看 n 越大時 A 越好
但如果 n = 1 和 n = 2 時, A 是 <B 以及 A = B 的
所以不一定  
```

# 函式的漸進增長
```
也就是說把上面 A,B 演算法表示為 f(n),g(n)
而如果你找到一個數字 N,且當任何其他數字 n > N 時
f(n) 永遠比 g(n) 大時,則稱 f(n) 增長快於 g(n)

以上例子而言,你會發現當 N 等於 3 時
只要 n >= 3 (3,4,5.....) 
B 演算法一定大於 A,表示 B 增長快於 A
```

# 重點
```
(1) 常數可忽略
(2) 最高次項所相乘的"常數"可忽略(例如 3n^2 可忽略 3, 4n 可忽略 4 )
(3) 最高次項的"指數"越大,次數遞增越快
(4) 只要注意最高次項就好,其他可忽略(例如 2n^2+3n+1 只要注意 n^2 即可)


PS:
最高次項 :
例如 2n^5 + 3n + 4 => 最高次項是 n^5 / 最高次項的"常數"是 2 / 最高次項的"指數"是 5
```

# BigO
```
O(1)  常數階:無論常數時間多少都寫 O(1),不能寫 O(3),O(10)...
O(n)  線性階
O(n^) 平方階


◎常數階
int i,sum=0,n=100      // 執行 1   次
sum = (1+n)*n/2        // 執行 1   次
printf("sum")          // 執行 1   次

◎線性階
int i,sum=0,n=100      // 執行 1   次
for(i=1;i<=n;i++){     // 執行 n+1 次
    sum = sum+1        // 執行 1   次
}

◎對數階
int count =1
while(count<n){
    count = count*2
}
這裡可以看到迴圈中的 count 每次都會*2
而迴圈結束條件就是 count >= n 的時候
例如
n     迴圈次數
1        0
2        1
3        3
20       4
...       ..


可以發現當 n 越大時, 迴圈執行次數會以 2^n 來判斷
因為 count = count*2
所以 count 每次迴圈會等於
0 -> 1 -> 2 -> 4 -> 8 -> 16 -> 32 -> 64 -> 128 .....
也就是
2^0 -> 2^1 -> 2^2 -> 2^3 -> 2^4 -> 2^5 -> 2^6 -> 2^7 ...

所以此演算法會執行 x 次,且條件為 2^x >= n
使用對數運算 => x = (logn 底為 2)
所以 Big O = O(logn)


◎平方階
雙迴圈時會發生
```

# 最壞與平均
```
例如你有一個數列,包含 100 個隨機數字
你要找 37,有可能第一個就找到,有可能最後一個才找到

所以一般都是使用最壞時間複雜度,也就是最久要執行多久
另一個是平均複雜度,也就是算出所有情況後,然後平均時間
也就是如果 37 在第 2 個找到的時間 + 37 在第 2 個找到的時間 + 37 在第 3 個找到的時間.....
最後時間除以 100 得到的平均時間

一般都是使用"最壞時間複雜度"
```

# 空間換時間
```
我們可以用儲存空間來換算法時間
例如你可以設計一個演算法計算閏年(需要計算時間不需要空間)
或是直接先儲存是閏年的年數直接來查詢(需要空間儲存,但查找也是需要時間,但相對比演算法快)
```
